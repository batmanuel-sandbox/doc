\documentclass{book}
\usepackage{hyperref}
\usepackage{verbatim}

\def\t{\texttt}
%\renewcommand{\t}[1]{\texttt{#1}}

\title{Scientists' Guide to the LSST Applications Software}
\author{David Wittman, Desire\'{e} Abbott, and a cast of thousands}

\begin{document}
\maketitle

\chapter*{Purpose of this Document}

The Large Synpotic Survey Telescope (LSST) Data Management (DM) team
have developed a large set of software modules for astronomical image
reduction and analysis.  The code is open-source and designed to be
generally useful for all sorts of imaging surveys.  Development has
reached the point where it may be useful for scientists inside or
outside the LSST project to use the software for general work.  This
guide is intended for scientists who have not written any of the code
and who are unfamiliar with the tools upon which the LSST software
stack is built.  It contains pointers to resources for those who wish
to drill down very deeply, but aims to be reasonably self-contained
for newbies.

In LSST world, we write number-crunching code in C++ and string
together the number-crunching steps with Python.  This allows us to
take advantage of the speed of C++ when necessary, and the ease of
Python otherwise.  You may be familiar with SciPy/NumPy, which give
you the ease of Python\footnote{If you are not familiar with Python,
  you should become familiar with it, even if you have no plans to
  work with LSST software.  It's extremely useful.  See XXX for a good
  tutorial.} while enabling the speed of C++ ``under the hood.''  You
can think of the LSST software as providing astronomy-specific
functionality ``under the hood'' in a similar way, but you will not be
quite as insulated from the C++ details as you would be with
SciPy/NumPy.  This document assumes that you will be writing Python
rather than C++, but you may need to refer to the C++ documentation to
see what features are available.  We will guide you through that
process.

\chapter*{Acknowledgments}

The LSST DM Applications team has worked very hard to produce these
tools.  In alphabetical order, they are: Tim Axelrod, Andy Becker,
Steve Bickerton, Martin Dubcovsky, Simon Krughoff, Dustin Lang, Robert
Lupton, Fergal Mulally, Russell Owen, Nicole Silvestri, and I've
probably missed many more.  Our fearless leader is Robert Lupton.
K.-T. Lim from the LSST DM Middleware team has also made enormous
contributions.



\chapter{Hello, world\label{chap-hello}}

This section gives you a very basic idea of how to get started with
simple tasks.  Once you have the LSST software stack installed (see
Appendix~\ref{appendix-stackinstall}), try these examples.  Remember
to source loadLSST.csh or loadLSST.sh before starting Python.  These
examples are designed to be run in interactive mode, so just type
\texttt{python} to start and copy/paste the examples in.  If you
prefer to save the examples to local files and then run Python on them
in noninteractive mode, be aware that the examples build on previous
examples as if you were continuously in interactive mode.  For
example, we create and use an object called \texttt{im1} in the first
example, and we use it again in the second example without explicitly
creating it again.


\section{Reading and displaying a FITS image}

The main package we'll be using is the \texttt{afw} (applications
framework) package, so we start by importing some afw subpackages.
Remember to \t{setup afw} at your Unix prompt after sourcing
loadLSST.csh but before starting Python (see the end of
Appendix~\ref{appendix-stackinstall} if you're not sure why).

\begin{verbatim}
import lsst.afw.display.ds9 as ds9
import lsst.afw.image as afwImg

im1 = afwImg.ImageF(`image1.fits')
ds9.mtv(im1, frame=0)
\end{verbatim}

Use the name of any handy FITS image in place of image1.fits.
\texttt{ImageF} creates an image of floats, \texttt{ImageD} creates an
image of doubles.  If you do not already have ds9 running, Python will
start it for you at this point.

\section{Image arithmetic}

To save memory and time, images are operated on in-place.  That is,
you can subtract images of identical size like this:

\begin{verbatim}
im2 = afwImg.ImageF('image2.fits')
im1 -= im2
\end{verbatim}

Be careful: this modifies im1!  If you were looking to do something
like \texttt{im3=im1-im2}, where im3 is a new image, you must
explicitly force the creation of the new image and {\it then} do the
in-place arithmetic:

\begin{verbatim}
im3 = afwImg.ImageF(im1,True)
im3 =- im2
\end{verbatim}

Again, this is because when working with large amounts of data we want
to minimize the amount of pixel copying.  The system is designed to
avoid new copies unless explicitly asked.

The first line above creates a new copy of im1, called im3.  There are
two very important things to note about this line:

\begin{itemize}

\item Setting the second argument to \texttt{True} is necessary to
  make a {\it deep copy}, meaning that the resulting image is a
  completely new image, independent of the parent image and occupying
  its own area of memory.  If the second argument is \texttt{False} or
  is omitted, a shallow copy is generated, meaning that the copy {\it
    still refers to the pixel values stored in the parent image}.
  Thus, if the pixels of a shallow copy are modified, the
  corresponding pixels in the parent image will be modified as well.
  {\it Astronomers who are new to the concept of deep and shallow
    copies will want to pay particular attention to this point.}
  Shallow copies save memory and time (for example, making postage
  stamps from a large image can be very fast and efficient) but you
  must handle them properly (don't modify the postage stamps if you
  will need to refer to the original pixel values).

\item If you are not familiar with object-oriented programming, you
  may be surprised to see that the ``function'' \texttt{ImageF}, which
  was previously called with a string (the filename) as its first and
  only argument, is now being called with {\it two} arguments, the
  first of which is not even a string.  This is a powerful
  feature. Conceptually, we know that an image can be constructed in
  many different ways.  However, many programming languages in the
  past forced us to declare different names for procedures which
  operate on different data types or take different numbers of
  arguments, even if they are conceptually similar.  With C++ and
  Python, conceptually similar operations can have the {\it same
    name}.  \texttt{ImageF} is not really a function; in
  object-oriented lingo it is a called a {\it method}.  Because it
  makes a new object, it is more specifically called a {\it
    constructor}.  We will soon see how to browse the C++
  documentation for all the different ways to construct an image.

\end{itemize}

Similar operators \texttt{+=}, \texttt{*=}, and \texttt{/=} are
defined, which do the obvious things.  The object on the right-hand
side can also be a scalar rather than an image.

\section{Masked images}

So far this may seem rather mundane, but the framework has some
features that will make it much more powerful with almost no extra
work on your part.  For example, we often want to propagate
uncertainties through these arithmetic operations, and apply masks
which ensure that the operations are not done on bad areas of the
image.  The applications framework defines a \texttt{maskedImage}
which contains an image, a variance image, and a mask image.
Once you have constructed \texttt{maskedImage}s, masking and
uncertainty propagation is done {\it automatically} when you invoke
these arithmetic operations.

A couple caveats first, before the examples:
\begin{itemize}
\item The mask part of MaskedImage is not just another image but
is created with MaskU, where the ``U'' stands for ``unsigned''.
\item The error message you get when you use a constructor
incorrectly is not very specific.  You might get a list of all
possible constructors, which is not very helpful when there
are dozens and you just want to know where your one little mistake
is.  (Not that the software COULD know what you mean, of course,
but it's different from say, C, where the compiler knows what type
the third argument should be, and tells you quite specifically when you
give it the wrong type.)
\end{itemize}

To create a masked image from nothing, use the following example, substituting your own dimensions for the ones included here.

\begin{verbatim}
a = afwImg.ImageF(10,10) # image
v = afwImg.ImageF(10,10) # variance image
m = afwImg.MaskU(10,10) # mask
mi = afwImg.MaskedImageF(a,m,v) # put it all together into one maskedImage
\end{verbatim}

To create a masked image using files of your own for the image and variance image, simply replace the dimensions in the example above with the usual string of the file name.  Make sure that the mask you create has the same dimensions as your images!  We will explain later how to specify which mask planes you want to use in your masked image.

\section{Image statistics}

\texttt{math.makeStatistics} computes image statistics and returns an
object which you can then query for the statistics you want.  To save
computation time, you specify beforehand which statistics to compute,
as follows:

\begin{verbatim}
import lsst.afw.math as math

flags = math.MEAN | math.STDEV | math.ERRORS 
stats = math.makeStatistics(im1,flags)

print stats.getResult(math.STDEV) # prints stdev AND its uncertainty
print stats.getResult(math.MEAN) # ditto for mean

\end{verbatim}

Possible statistics to calculate:
\begin{itemize}
\item ERRORS     Inlude errors of requested quantities.
\item NPOINT     number of sample points
\item MEAN     estimate sample mean
\item STDEV     estimate sample standard deviation
\item VARIANCE     estimate sample variance
\item MEDIAN     estimate sample median
\item IQRANGE     estimate sample inter-quartile range
\item MEANCLIP     estimate sample N-sigma clipped mean
\item STDEVCLIP     estimate sample N-sigma clipped stdev
\item VARIANCECLIP     estimate sample N-sigma clipped variance
\item MIN     estimate sample minimum
\item MAX     estimate sample maximum
\item SUM     find sum of pixels in the image
\item MEANSQUARE     find mean value of square of pixel values
\item NOTHING     We don't want anything.
\end{itemize}

This list is provided here to give you an idea of the capabilities in
the system, but capabilities change over time.  It's a good idea to
check the C++ documentation (as described below) for the most
up-to-date list.  The main selling point is not that you can compute
statistics---many software packages can do that---but that if you use
\texttt{maskedImage}s, the masks are {\it automatically applied} when
computing the statistics.

If you want detailed control over how the statistics are computed, for
example {\it not} using the masks, or changing the clipping from the
default 3$\sigma$ and 3 iterations, you must create a
StatisticsControl object with five arguments: the number of sigma to
clip at, the number of iterations for clipping, a specification of
which bitplanes of the mask to use (0 means use all of them; mask
bitplanes will be explained further in Chapter~\ref{chap-overview}), a
boolean indicating whether to avoid using pixels which have NaN
(not-a-number) values, and a boolean indicating whether to weight
pixels by their inverse variance.  In the example below, we use all
the default values except to ask for 5$\sigma$ rather than 3$\sigma$
clipping.

\begin{verbatim}
ctrl = math.StatisticsControl(5.0,3,0,True,False)
stats = math.makeStatistics(im1,flags,ctrl)
print stats.getResult(math.STDEV) 
\end{verbatim}

In this case, we get a larger STDEV because we clipped less harshly
than the default.


\section{Cutting, copying, pasting, and writing images}

To cut out a sub-image, we must first create a \texttt{BBox} or
bounding box object, which itself must be defined by two
\texttt{PointI}\footnote{\texttt{PointI} defines a point where the
 coordinates are integers, hence the ``I''.}  objects which specify
the corners.  We then call \texttt{ImageF} in a new way:

\begin{verbatim}
llc = afwImg.PointI(290,250)
urc = afwImg.PointI(300,260)
bbox = afwImg.BBox(llc,urc)
im4 = afwImg.ImageF(im1,bbox,False)
\end{verbatim}

\texttt{llc} and \texttt{urc} define the lower left and upper right
corners of the bounding box, respectively.  This form of the
\texttt{ImageF} constructor takes an image as its first argument, a
bounding box as its second argument, and thirdly the boolean
indicating the type of copy (\texttt{False} indicating that a deep
copy should not be made).  Shallow copies are excellent for
efficiently extracting postage stamps, as long as you remember the
implications of modifying their pixel values.

You can set pixel values using the \texttt{<<=} operator.  For
example, if you wanted to set all the pixels inside the bounding box to a
scalar value, say 99:

\begin{verbatim}
im4 <<= 99
\end{verbatim}

This also works if the right-hand side is an image of the correct size.

You can also easily mosaic images together.  The following example
makes a new mosaic image in memory and displays it.  This would be
useful for making a picture gallery of interesting galaxies, for
example.

\begin{verbatim}
import lsst.afw.display.utils as utils

im1 = afwImg.ImageF(`image1.fits')
im2 = afwImg.ImageF(`image2.fits')
im3 = afwImg.ImageF(`image3.fits')
im4 = afwImg.ImageF(`image4.fits')

images = [im1, im2, im3, im4]
labels = [`Label 1', `Label 2', `Label 3', `Label 4']

m = utils.Mosaic()
m.setMode(`square')
m.setGutter(0)

mosaic = m.makeMosaic(images)
ds9.mtv(mosaic, frame=0)
m.drawLabels(labels, frame=0)
\end{verbatim}

In the \texttt{setMode} command, the default is ``square'' which will
make the mosaic image as square as possible.  Other allowed values are
``y'' and ``x'' which make the mosaic one image wide and one image
high, respectively.  The \texttt{setGutter} command sets the number of
pixels between each image in the mosaic.

To save your mosaic image as a new FITS file:

\begin{verbatim}
afwImg.ImageF.writeFits(mosaic,'filename.fits')
\end{verbatim}


%See also the ``How to display an image'' link on the ``Related Pages''
%tab of the aforementioned documentation, for additional image
%commands.

\vskip0.5in

This concludes our set of ``Hello, world'' examples.  To move beyond
these very simple tasks, we must first get an overview of what's
available in the LSST packages.

\chapter{Overview of LSST Packages\label{chap-overview}}

Having demonstrated how easy it is to do powerful things with this
software, let's take a brief look at each of the available packages
and what they can do.  Later in this book, each package will star in
its own more detailed chapter.

\section{Online documentation}

It will be useful to browse the online documentation while reading
through this chapter.  As the C++ programmers write their code, they
build in a certain amount of documentation through a system called
Doxygen.  Doxygen generates a web page for each package and class and
makes it relatively easy to click through.  For example, if a method
takes an argument of a type you don't recognize, you should be able to
click on it and get the definition of that type.

The most convenient version of the Doxygen docs is available online at
\url{http://www.astro.princeton.edu/~rhl/LSST/Doxygen/htmlDir/index.html}.
While the code is constantly changing, this website is not constantly
updated; however, it should be sufficient for most needs.  If necessary,
there is a way to generate the docs from the exact version of the code that
exists on your computer, but it won't be as nicely crosslinked as this
version; you will have to search each package separately, for example.

This section will describe how to navigate the online documentation,
but first we must discuss the concept of {\it namespace}.  In older
languages such as Fortran and C there is only one namespace; each
distinct function must have a distinct name.  This could become a
problem if you were using multiple third-party libraries and different
libraries happened to use the same name for different things,
resulting in a {\it name collision}.  In Python and C++, name
collisions are avoided by having multiple namespaces.  For example, in
Python the statement \texttt{import lsst.afw.image as afwImg} means
that there is an lsst namespace, within that an afw namespace, and
within that an image namespace; and to avoid the hassle of constantly
typing lsst.afw.image, we will define afwImg as a nickname.  So we can
refer to the constructor \texttt{lsst.afw.image.ImageF} as \texttt{afwimage.ImageF}
without worrying that there might also be an \texttt{ImageF} defined
in \texttt{some.other.package}; that \texttt{ImageF} would have to be
referred to as \texttt{some.other.package.ImageF}.  See
\url{http://docs.python.org/tutorial/classes.html#python-scopes-and-namespaces}
for a more detailed description.


\subsubsection{Navigating the maze:  The tabs}

Go ahead and click on
\url{http://www.astro.princeton.edu/~rhl/LSST/Doxygen/htmlDir/index.html}
if you haven't already.  The {\it Main Page} is titled {\it lsst::afw; the
LSST Application Framework} and is indeed afw-centric.  While afw is
the obvious starting place for newbies, keep in mind that there is a
{\it lot} of functionality in other namespaces, and it's {\it all}
documented here, despite the title.  The major difference is that afw
has a fair amount of readable documentation here which goes above and
beyond the standard ``here is the definition of class foo and here are
all of its constructors.''  The main page links directly to a handful
of useful writeups, such as {\it How to display images}.

The {\it Namespaces} and {\it Classes} tabs will be your workhorses.
Clicking on the Namespace tab yields an alphabetical list of
namespaces.  One quirk: some namespaces within afw are listed first,
because afw is first alphabetically; but others are listed under
lsst::afw. (Note: the '::' separator is C++'s equivalent of Python's
'.' separator for namespaces.)  The reason for this is that some
namespaces were defined in Python and some in C++; Doxygen makes the
former appear as afw::xxxx while the latter appear as lsst::afw::xxxx.
Although of no real significance, it can be confusing: clicking on
afw::image yields a very boring page containing only testUtils and
utils, while clicking on lsst::afw::image yields the richly detailed
page you really wanted.  

Classes are the abstract definitions of what we previously referred to
as ``objects.'' For example, lsst::afw::image::ImageF is a class.
When we use the constructor lsst::afw::image::ImageF(filename), it
returns an object of that type.  Internally, classes contain data
members (for example, the size of the image), but these are generally
not accessible externally.  All external manipulations are supposed to
be done using the methods listed.  Note that if you go to the Classes
tab, you will {\it not} find lsst::afw::image::ImageF. Rather, you
will find \texttt{lsst::afw::image::Image< PixelT >}.  This is
because Image is a {\it templated} class.  The bit in angle brackets
is a stand-in for F, D, or I depending on whether the image is float,
double, or int.  Templates allow C++ programmers to write the code
once, and have the compiler ``expand the template'' for them, rather
than write essentially the same code over again for each new type.

Go ahead and click on the \texttt{lsst::afw::image::Image< PixelT >}
you find listed in the Namespaces tab.  As promised in the previous
chapter, you will find all the gory detail of all the different
constructors and operators that have been defined.  (Note: rhs and lhs
stand for right-hand side and left-hand side respectively.)  You will
often see the same operator defined multiple times.  For example, '-='
is defined once for a scalar rhs and once for an image rhs.  This is
what allows you, the Python programmer, to put either type on the rhs
and have it just work automatically.

A further word on navigation: at the top of the page you see the
clickable text \texttt{lsst::afw::image::Image}.  Note that {\it each
  item separated by :: is separately clickable}.  So if you want to
see what else is in the \texttt{lsst::afw::image} namespace, click on
the first \texttt{image}; to see what else is in the
\texttt{lsst::afw} namespace, click on \texttt{afw}, etc.  This is
often a useful way to get where you want, if you find the
semi-alphabetical listing of namespaces in the Namespaces tab too
confusing.

For completeness, we also describe the less oft-used tabs.  The {\it
  Related Pages} tab contains a fairly long list of pages which are
meant to be tutorials or introductions in the style of those linked to
from the Main Page.  But many of these pages are blank, and some of
the non-blank ones have syntax errors or are out of date.  These may
still be useful as a rough guide to how the developers intended the
code to be used, but do not expect them to work verbatim.  Ignore the
{\it Modules} tab; ``module'' is not a well-defined concept as is
namespace or class, and here it contains an odd collection of things.
The {\it Files} and {\it Directories} tabs list all source code files and
directories; while straightforward, these are not immensely useful to
the beginner.  But note that everything is clickable, so if you must
hunt through source code files and directories, doing it here may be
more convenient than doing it at your Unix prompt.  The {\it Examples}
tab will be useful mainly for C++ programmers.

Ready?  Fasten your seat belts for a quick tour through LSST land!

\section{lsst::afw}

The application framework defines basic behavior of images, background
models, source detections, and the like, as well as supporting actors
such as bounding boxes. At the highest level (\url{http://www.astro.princeton.edu/~rhl/LSST/Doxygen/htmlDir/namespacelsst_1_1afw.html}\footnote{Not
  to be confused with
  \url{http://www.astro.princeton.edu/~rhl/LSST/Doxygen/htmlDir/namespaceafw.html},
  as mentioned above.}) we see only eight items, the namespaces
\texttt{cameraGeom, coord, detection, display, formatters, geom,
  image}, and \texttt{math}.  Rest assured, there is a lot within!
The really useful namespaces are \texttt{detection, display}, and
\texttt{image}.  We'll start with \texttt{image} because it's so
fundamental.

%\footnote{For
%  completeness, scons and SconsUtils are for compiling the C++ code;
%  cameraGeom defines things like amps, ccds, and rafts; and geom
%  defines ellipses.}  

\subsection{lsst::afw::image}

Defines basic behavior of images.

\subsection{lsst::afw::detection}

Tools for detecting sources in images.

\subsection{lsst::afw::display}

Tools for displaying images and (presumably) associated helpers like
bounding boxes.

\section{lsst::meas}

\section{lsst::ip}

\subsection{lsst::ip::isr}

\subsection{lsst::ip::diffim}




\chapter{Extended examples}

\section{Using the ISR to remove instrumental signature from your data}

\section{Writing Sextractor in 100 lines of python}
 
\chapter{How do I...}

We've seen that when browsing the online documentation, it's quite
easy to look at a C++ definition and see how to use it in Python and
what it's useful for.  It's much harder to go the other way: given a
goal, what are the classes that enable that goal?  This chapter
provides answers for common tasks. If you encounter a task you think
should be listed here, just send it to us and we'd be happy to include
it.

%
% Here's where we want to include chapters from each package.
% 
%\chapter{}
%\include{}

\appendix

\chapter{Installing the LSST Software
  Stack\label{appendix-stackinstall}}

%\section{How do I install all this stuff?}

The place to start is
\url{http://lsstdev.ncsa.uiuc.edu/trac/wiki/Installing}.  From here
you can jump to {\it Installing on Linux} or {\it Installing on
  Macintosh}.  Don't worry that the list of officially supported
platforms is short and probably doesn't include yours; in practice,
the stack should run on most Linux or Mac systems with only minor
tweaks, and most developers actually work on ``unsupported''
platforms!  The ``supported'' moniker indicates that when push comes
to shove, the highest priority for the project is that the code runs
on the big Linux clusters that will be used for production.  But if
you need help on an ``unsupported'' platform, ask around and you will
most likely get help.

The code does tend not to work on the absolute latest versions of
things (for example MacOS 10.6 and Linux versions which use gcc 4.4,
although there is an easy workaround for the latter).  Machines with
middle-aged OS's like MacOS 10.5 and Linux versions with gcc 4.3 are
going to work out of the box.

This author installed on Ubuntu 10.04, so we will go through the
process step-by-step for that OS.  Clicking on {\it Installing on
  Linux}, we get to a page which (at the bottom) lists the OS packages
which must be present before the stack can be installed; for
Debian/Ubuntu, we see g++, subversion, etc.  Copy and paste the
apt-get command for installing all these packages. It may vary
slightly for other versions of Ubuntu/Debian, as package names
sometimes change.

With that done, rejoin the OS-independent part of the install
instructions at
\url{http://dev.lsstcorp.org/GettingStarted.html#lsst_home}.  They ask
you to define a few environment variables, choose a directory to
install into (user space is probably best), grab the install script
from the given URL, and run it.  That's it.  It should take at least
60 minutes to download and compile everything. 

A warning: the install script may say "Installation complete" at the
end even if previous steps have failed!  Be sure to skim the output of
the install script to see if everything went ok.  In the case of
Ubuntu 10.04, afw fails to compile; this turns out to be a known issue
with a known, easy fix\footnote{So why doesn't the project
  automatically apply the fix?  Because it only occurs with gcc 4.4,
  which hasn't been officially adopted yet. By the time it is, a new
  version of the third-party library with the relevant bugfix will
  also be adopted.} described at
\url{http://dev.lsstcorp.org/trac/ticket/1124} (note: you may need a
login to see this part of the dev.lsstcorp.org site).  After applying
the fix, the install script runs to completion.

You may wish to scroll down the install instructions page for a brief
explanation of the subdirectory structure that's been installed.  This
explanation is most relevant for power users who will be running
multiple versions and platforms.

To use the software you must perform two configuration steps:
\begin{enumerate}
\item Tell Python where to find the LSST packages by
  running \\ \texttt{source /your/install/path/loadLSST.csh} (or loadLSST.sh
  for bash users).  You can test this by starting Python in
  interactive mode (just type \texttt{python}) and then telling Python
  \texttt{import lsst}.  If that doesn't fail with an error (sucess
  will be silent), then loadLSST.csh has done its job.

\item For each package you wish to use, specify which version of that
  package you wish to use by running \texttt{setup [packagename]} on the
  Unix command line, for example \texttt{setup afw}.  Setup is designed to
  help developers switch different versions of, eg, afw in and out for
  testing.  Most readers of this document will not wish to do that,
  but will still need to run setup without specifying any particular
  version; this automatically pulls in the latest version.  You can
  test this step by again entering Python in interactive mode and
  typing \texttt{import lsst.afw}.  Note that the package names you specify
  to setup are less hierarchical than the corresponding Python or C++
  namespaces.  For example, you would \t{setup meas\_astrom} and then
  \t{import lsst.meas.astrom}.  You do {\it not} \t{setup meas::astrom} or 
  \t{setup meas.astrom}.

\end{enumerate}

Now you are ready to try the hello world examples in
Chapter~\ref{chap-hello}! 


\chapter{Overview of Third-Party Tools\label{appendix-thirdparty}}

The LSST C++ programmers themselves build upon numerous open-source
libraries and tools.  This appendix gives a brief overview of those
tools.  You do not have to read it thoroughly to make sense of the
rest of this document, but it may be useful to have some reference
point for the various terms that may appear when you install and run
the software.  LSST has blessed certain versions of these things as
the official LSST versions, which are installed in one big gulp by the
procedure described in Appendix~\ref{appendix-stackinstall}.  Thus you
do not have to follow the URLs in this appendix; they are for your
information only.

\section{SCons}

Think of SCons (\url{http://www.scons.org}) as the new ``make.''  (The
name comes from ``software construction.'')  Why don't we simply use
make?  Because SCons is more powerful; an SCons script {\it is} a
Python script, so it has the full power of Python when necessary, but
it automates the routine jobs.  That said, SCons will take some
getting used to if you are writing and building C++ code.  Those of
you sticking to Python will not need it.

\section{EUPS}

EUPS is the Extended Unix Product System.  It's a way to manage all of
the versions of all of the libraries and tools you may have on your
system.  For example, if you already have NumPy installed but it's not
the official LSST version, you need to set up various paths so that
when you run LSST software, it uses the expected version.  You do {\it
  not} have to delete your personal version, which you may need for
other projects.  (LSST software may in fact run with your
pre-installed version, but that is not guaranteed, and you will not
receive much help from the project if you encounter problems this
way.)  EUPS is designed to make this easy even in the presence of all
the various LSST and third-party packages with all their versions and
running on many different flavors of OS.  EUPS grew out of a similar
tool written by astronomers for the Sloan Digital Sky Survey, and is
now maintained by LSST.  Its home page appears to be
\url{http://dev.lsstcorp.org/trac/wiki/Eups}.

\section{svn}

As a user rather than an LSST developer, you may never have to use
svn, but you will likely hear references to it.  SVN (short for
``subversion'', \url{http://subversion.tigris.org}) is a modern
software repository system.  When developers check in new versions of
code, svn automatically saves the old version, records who checked in
the new version, can generate diffs when requested, etc.  And it's not
limited to code; the writers of the LSST Science Book used svn to
coordinate the contributions of hundreds of authors.  There is a
distinction between svn the software on one hand, and any particular
svn repository on the other.  LSST DM has one repository, the LSST
Science Book has another, and thousands of other software projects
have their own svn repositories.  An example of the kind of thing EUPS
should do is set up an environment variable that tells svn where the
LSST DM repository is, rather than force you to type it on the svn
command line.

Most large software projects make a public release by extracting a
particular snapshot of their svn repository and making it downloadable
in, say, one big gzipped tar file.  Users who download it thus do not
need an svn client; access to the bleeding-edge version of the code
would actually be harmful for many people.  LSST software is not quite
this publicly-accessible, but XXX

\section{Other third-party packages}

The LSST software stack makes use of many other third-party packages,
for example Boost, a set of general-purpose C++ libraries; cfitsio;
swig (a system for making C++ and Python, among other languages, work
together); Python and various Python modules; etc.  You probably don't
need to worry about any of these in any detail, but you will likely
see their names when you drill down a little deeper than this
document.

% Do we need these?
% \chapter{Glossary}
% \chapter{Index}

\end{document}

